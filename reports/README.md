# 2022年2022年开源操作系统训练营第一阶段总结

##  Rust语言学习
- 作为系统级语言，不需要gc，不用关心内存溢出的情况。相比于其他语言，个人感觉这个特性很有说服力
- 面向对象编程，作为一个一直使用java和c#的开发者而言，继承封装多态已经深入骨髓
- 可能接触的没有过于深入，感觉Rust的代码比c++更容易让人明白，不需要声明与实现分离，引用只需要use即可
- 强类型，特别特别的强类型，一开始有些不习惯，后来慢慢习惯了，感觉Rust的作者很谨慎，宁愿报错也要效率和节省内存
- Cargo的功能堪比maven，Nuget和mpn，论一个包管理的重要性
- 指针和引用还在，虽然讨厌，但是不得不接受他的存在，据说俄罗斯的开发者为何厉害，因为他们喜欢指针套指针，能套五层。
## rcore
### 通过实验一，让我对计算机的启动和答题的工作有了一定的了解，包括批处理和分时任务
- OS启动过程
1. 通电后，CPU的通用寄存器清零(.bss段)
2. PC指向0x1000（有固化再硬件中的一小段引导代码）
3. 跳转到RustSBI（0x80000000）
4. 硬件加载完成后跳转到$(KERNEL_BIN) 所在内存位置 0x80200000
5. 执行第一条指令
- 罪魁祸首：三元组-当去除标准库后，一切就变得那么的不美好了，什么都要自己写
1. 切换目标平台
2. 指定连接器连接的文件（设置入口点，目标平台，指令存放地，各段的地址）
3. 配置空间布局，入口点指向的Rust代码；预留操作系统使用空间；栈顶和栈底
4. 入口点函数与配置空间布局汇编连理联系
5. 清空.bss段，谁知道这个地址的内存以前放的是啥
6. 移除println!宏，需要自己写一个
7. 将main函数变为入口点
8. 添加退出机制
9. 运行
- QEMU有两种运行模式：
1. User mode 模式，即用户态模拟
2. System mode 模式，即系统态模式
- 懒加载的妙用
1. 声明了main函数，不过是懒加载，当出现其他main函数时（相同函数名的函数更准确）就会加载并作为入口点执行
2. 这让我感觉像是继承，当方法被覆盖后，就应该执行覆盖后的方法，只是没想到连入口函数也能这么玩
3. 这样带来的好处是，同时声明多个入口点（main函数），就会被执行多次。
- 无时无刻的上下文
1. 当通过特权级进行切换时，需将原有的上下文进行保存，以便切换回来还能继续运行
2. 上下文范围很广，程序上下文，进程上下文：控制流上下文，Trap上下文，只要存在中断，就有上下文
- Trap
1. 特权级的根本：sstatus的SPP字段的修改（S和U）
### 通过实验二，让我了解了内存空间的相关知识
